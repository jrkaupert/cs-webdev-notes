[Table of Contents](_toc.md)

[Previous Chapter](ch2.md)

# Chapter 3: Organizing objects with classes #
While objects can be created with `Object.new` and provided methods one at a
time, Ruby offers classes as a way of bundling behaviors so many similar objects
can be created easily.

Every object is an instance of a class, and classes are a way of organizing
objects and methods

## 3.1 Classes and Instances ##

### 3.1.1 Instance Methods ###

### 3.1.2 Overriding methods ###

### 3.1.3 Reopening classes ###

## 3.2 Instance variables and object state ##

### 3.2.1 Initializing an object with state ###

## 3.3 Setter methods ##

### 3.3.1 The equal sign (=) in method names ###

### 3.3.2 Syntactic sugar for assignment-like methods ###

### 3.3.3 Setter methods unleashed ###

## 3.4 Attributes and the attr_* method family ##

### 3.4.1 Automating the creation of attributes ###

### 3.4.2 Summary of attr_* methods ###

## 3.5 Inheritance and the Ruby class hierarchy ##

### 3.5.1 Single inheritance: One to a customer ###

### 3.5.2 Object ancestry and the not-so-missing link: The Object class ###

### 3.5.3 El Viejo's older brother: BasicObject ###

## 3.6 Classes as objects and message receivers ##

### 3.6.1 Creating class objects ###

### 3.6.2 How class objects call methods ###

### 3.6.3 A singleton method by any other name... ###

### 3.6.4 When, and why, to write a class method ###

### 3.6.5 Class methods vs. instance methods ###

## 3.7 Constants up close ##

### 3.7.1 Basic use of constants ###

### 3.7.2 Reassigning vs. modifying constants ###

## 3.8 Nature vs. nurture in Ruby objects ##

[Table of Contents](_toc.md)

[Next Chapter](ch4.md)
